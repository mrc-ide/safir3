# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title Compute vaccine efficacy against infection from Ab titre (C++)
#' @param ab_titre a vector of Ab titres
#' @param parameters model parameters
#' @param day current day
#' @return a numeric vector, 0 is maximally proective, 1 is maximally unprotective
#' @export
nat_efficacy_infection_cpp <- function(ab_titre, parameters, day) {
    .Call('_safir3_nat_efficacy_infection_cpp', PACKAGE = 'safir3', ab_titre, parameters, day)
}

#' @title Compute vaccine efficacy against severe disease from Ab titre (C++)
#' @description This needs the efficacy against infection because efficacy against severe disease,
#' conditional on breakthrough infection is what safir3 needs, which is computed as  1 - ((1 - efficacy_disease)/(1 - efficacy_infection)).
#' @param ab_titre a vector of Ab titres
#' @param ef_infection a vector of efficacy against infection from \code{\link{vaccine_efficacy_infection}}
#' @param parameters model parameters
#' @param day current day
#' @return a numeric vector, 0 is maximally proective, 1 is maximally unprotective
#' @export
nat_efficacy_severe_cpp <- function(ab_titre, ef_infection, parameters, day) {
    .Call('_safir3_nat_efficacy_severe_cpp', PACKAGE = 'safir3', ab_titre, ef_infection, parameters, day)
}

#' @title Compute vaccine efficacy against onward transmission from Ab titre (C++)
#' @param ab_titre a vector of Ab titres
#' @param parameters model parameters.
#' @param day current day
#' @return a numeric vector, 0 is maximally protective, 1 is maximally unprotective
#' @export
nat_efficacy_transmission_cpp <- function(ab_titre, parameters, day) {
    .Call('_safir3_nat_efficacy_transmission_cpp', PACKAGE = 'safir3', ab_titre, parameters, day)
}

#' @title C++ infection process (modified squire transmission model)
#' @description this is an internal function, you should use the R interface
#' for type checking, \code{\link{infection_process_cpp}}
#' @param parameters a list of parameters from \code{\link{get_parameters}}
#' @param states a \code{\link[individual]{CategoricalVariable}}
#' @param discrete_age a \code{\link[individual]{IntegerVariable}}
#' @param receive_antivirals a \code{\link[individual]{IntegerVariable}}
#' @param infectiousness_start_time a \code{\link[individual]{IntegerVariable}}
#' @param infection a \code{\link[individual]{TargetedEvent}}
#' @param dt size of time step
infection_process_cpp_internal <- function(parameters, states, discrete_age, infectiousness_start_time, wearing_ppe, infection, dt) {
    .Call('_safir3_infection_process_cpp_internal', PACKAGE = 'safir3', parameters, states, discrete_age, infectiousness_start_time, wearing_ppe, infection, dt)
}

#' @title C++ infection process (modified squire transmission model)
#' @description this is an internal function, you should use the R interface
#' for type checking, \code{\link{infection_process_cpp}}
#' @param parameters a list of parameters from \code{\link{get_parameters}}
#' @param states a \code{\link[individual]{CategoricalVariable}}
#' @param discrete_age a \code{\link[individual]{IntegerVariable}}
#' @param receive_antivirals a \code{\link[individual]{IntegerVariable}}
#' @param infectiousness_start_time a \code{\link[individual]{IntegerVariable}}
#' @param infection a \code{\link[individual]{TargetedEvent}}
#' @param dt size of time step
infection_process_vaccine_cpp_internal <- function(parameters, variables, states, discrete_age, infectiousness_start_time, wearing_ppe, infection, dt) {
    .Call('_safir3_infection_process_vaccine_cpp_internal', PACKAGE = 'safir3', parameters, variables, states, discrete_age, infectiousness_start_time, wearing_ppe, infection, dt)
}

compare_floats <- function(a, b) {
    .Call('_safir3_compare_floats', PACKAGE = 'safir3', a, b)
}

#' @title Cross tabulate two vectors with given margins
#' @description this is a replacement for \code{\link[base]{table}} that allows empty
#' cells because the margins have been specified. The input vectors \code{a} and \code{b}
#' must be the same length, this function does no argument checking.
#' @param a one set of observations
#' @param b another set of observations
#' @param a_margin number of distinct values of a (rows)
#' @param b_margin number of distinct values of b (cols)
#' @examples
#' a <- 1:5
#' b <- c(1,2,3,1,2)
#' cross_tab_margins(a,b,5,3)
#' table(a,b)
#' @export
cross_tab_margins <- function(a, b, a_margin, b_margin) {
    .Call('_safir3_cross_tab_margins', PACKAGE = 'safir3', a, b, a_margin, b_margin)
}

#' @title Cross tabulate doses and age
#' @description The input vectors \code{doses} and \code{age}
#' must have the same number of values, this function does no argument checking.
#' @param doses a \code{\link[individual]{IntegerVariable}}
#' @param age a \code{\link[individual]{IntegerVariable}}
#' @param num_doses number of doses
#' @param num_ages number of age groups
#' @examples
#' \dontrun{
#' a <- IntegerVariable$new(0:4)
#' b <- IntegerVariable$new(c(1,2,3,1,2))
#' cross_tab_doses_age(a$.variable,b$.variable,4,3)
#' table(a$get_values(), b$get_values())
#' }
#' @export
cross_tab_doses_age <- function(doses, age, num_doses, num_ages) {
    .Call('_safir3_cross_tab_doses_age', PACKAGE = 'safir3', doses, age, num_doses, num_ages)
}

#' @title Cross tabulate compartments and age
#' @param compartments a [individual::CategoricalVariable]
#' @param age a [individual::IntegerVariable]
#' @param num_ages number of age groups
#' @param compartment_names a vector giving category names of the [individual::CategoricalVariable]
cross_tab_compartments_age <- function(compartments, age, num_ages, compartment_names) {
    .Call('_safir3_cross_tab_compartments_age', PACKAGE = 'safir3', compartments, age, num_ages, compartment_names)
}

cross_tab_margins_internal <- function(a, b, a_margin, b_margin) {
    .Call('_safir3_cross_tab_margins_internal', PACKAGE = 'safir3', a, b, a_margin, b_margin)
}

#' @title Tabulate a vector of observations
#' @description Tabulate a vector \code{a} whose values fall into a set of integers
#' of maximum value \code{nbins}. This function does no argument checking so please
#' ensure the maximum value of observations is not greater than \code{nbins}.
#' @param a a set of observations
#' @param nbins number of bins
#' @examples
#' nbin <- 10
#' a <- sample.int(n = nbin,size = 100,replace = TRUE)
#' tabulate(bin = a,nbins = nbin)
#' tab_bins(a = a,nbins = nbin)
#' @export
tab_bins <- function(a, nbins) {
    .Call('_safir3_tab_bins', PACKAGE = 'safir3', a, nbins)
}

#' @title Tabulate a weighted vector of observations
#' @description Similar to [safir3::tab_bins] but instead of each observation
#' being implicitly given weight 1, it now has weight given by `wt[i]`.
#' @param a a set of observations
#' @param wt a set of weights
#' @param nbins number of bins
#' @export
tab_bins_weighted <- function(a, wt, nbins) {
    .Call('_safir3_tab_bins_weighted', PACKAGE = 'safir3', a, wt, nbins)
}

#' @title Get contact matrix
#' @description Get the contact matrix at some specific day (1st dimension of array).
#' @param array the mixing matrix array (days x age x age)
#' @param i the day (indexes the first dimension, assumes zero indexing)
#' @export
get_contact_matrix_cpp <- function(array) {
    .Call('_safir3_get_contact_matrix_cpp', PACKAGE = 'safir3', array)
}

#' @title Get a value from a vector
#' @description Get a value at some specific day
#' @param vector_set the set of values
#' @param i the day (assumes zero indexing)
#' @export
get_vector_cpp <- function(vector_set, i) {
    .Call('_safir3_get_vector_cpp', PACKAGE = 'safir3', vector_set, i)
}

#' @title Multiply a matrix by a integer vector
#' @param m a matrix
#' @param a a vector (must have length equal to number of columns of \code{m})
#' @export
matrix_vec_mult_cpp <- function(m, a) {
    .Call('_safir3_matrix_vec_mult_cpp', PACKAGE = 'safir3', m, a)
}

#' @title Multiply a matrix by a integer vector and a double vector
#' @param m a matrix
#' @param a a vector of double (must have length equal to number of columns of \code{m})
#' @param b a vector of double (must have length equal to number of columns of \code{m})
#' @export
matrix_2vec_mult_cpp <- function(m, a, b) {
    .Call('_safir3_matrix_2vec_mult_cpp', PACKAGE = 'safir3', m, a, b)
}

#' @title Element-wise multiply two matrices and take row sums
#' @description This function does no argument checking, please make sure \code{a} and \code{b}
#' are matrices of the same dimension.
#' @param a a matrix
#' @param b a matrix
#' @export
mult_2matrix_rowsum <- function(a, b) {
    .Call('_safir3_mult_2matrix_rowsum', PACKAGE = 'safir3', a, b)
}

get_proportion_vaccinated_nimue_internal <- function(discrete_age, vaccinated, age) {
    .Call('_safir3_get_proportion_vaccinated_nimue_internal', PACKAGE = 'safir3', discrete_age, vaccinated, age)
}

